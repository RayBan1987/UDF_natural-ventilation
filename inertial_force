
/*report the inertial force */
/*first write txt head*/
DEFINE_INIT(txt_inertial_force,d)
{
	Thread *t, *tf;
	cell_t c;
	face_t f;
	real xc[ND_ND];
	real xf[ND_ND];
	real A[ND_ND];  /*store face normal vector*/
	int n=-1,cell_num=0; /*loop variable*/
	
	FILE *fp; /*pointer to a file */
	fp = fopen("inertial_force.txt","w+");
	
	fprintf(fp,"P_xmax P_xmin F_Y P_zmax P_zmin cell_num_xmax  cell_num_xmin  cell_num_zmax  cell_num_zmin\n");
	fclose(fp);
}

DEFINE_EXECUTE_AT_END(record_inertial_force)
 {
    Domain *d;
   	Thread *t,*tf;
    cell_t c;
	face_t f;
	real xc[ND_ND],xf[ND_ND];
	real A[ND_ND],cell_num_xmax=0,cell_num_xmin=0,cell_num_zmax=0,cell_num_zmin=0;

	real D,lf,xmax,xmin,zmin,zmax,source,volume,Q_xing;
	real DP_xmax=0,DP_xmin=0,DP_zmax=0,DP_zmin=0;
	real P_xmax=0,P_xmin=0,P_zmax=0,P_zmin=0,F_Y=0,f_buoyancy=0;
	real height_crit=0;
	int n=-1;
	
	FILE *fp; /*pointer to a file */
	fp = fopen("inertial_force.txt","a+");
	d = Get_Domain(1);       /* Get the domain using ANSYS FLUENT utility */
	
    D=2*(a+b)/M_PI;   /*D is perimeter diamter*/
	Q_xing=Q/(1.2*1.0*300*sqrt(9.81)*pow(D,2.5));
	lf=(3.7*pow(Q_xing,0.4)-1.02)*D;  /*calculate the height of fire*/
	if(lf>0.45)
	{	lf=0.45;}
	
	volume=a*b*lf;/*calculate the volume of fire source*/
	
    xmax=0.3+a/2;
    xmin=0.3-a/2;
    zmax=4.5+b/2;
    zmin=4.5-b/2;
	height_crit=0.5*lf;

   /* Loop over all cell threads in the domain */
   thread_loop_c(t,d)
      {
      /* Loop over all cells */
      begin_c_loop(c,t)
        {
         C_CENTROID(xc,c,t);  /*get the center coordinates of one cell*/
		 if (xc[0]<=xmax && xc[0]>=xmin && xc[2]<=zmax && xc[2]>=zmin && xc[1]<=height_crit)  /*whether flame region*/
		  {
			   f_buoyancy=(1.1774-C_R(c,t))*9.81*C_VOLUME(c,t); /*calculate the buoyancy force of fire grids*/
			   
			    c_face_loop(c,t,n) /*loop over all the faces of one cell*/
			   {
			      f=C_FACE(c,t,n);
				  tf=C_FACE_THREAD(c,t,n);
				  F_CENTROID(xf,f,tf); /*get the coordinate of a face*/
				  
				 if ((fabs(xf[0]-(xmax))<1e-4))/*indicates it is  boundary*/
				  {
					 cell_num_xmax++;
				   /*here puts integeral*/
				   F_AREA(A,f,tf);
				   DP_xmax=NV_MAG(A)*(F_P(f,tf)+0.5*C_R(c,t)*SQR(C_U(c,t)));/*pressure of a small element face*/	
				  }  
				else
					{
						if ((fabs(xf[0]-(xmin))<1e-4))/*indicates it is  boundary*/
						{
						  cell_num_xmin++;
					     /*here puts integeral*/
				         F_AREA(A,f,tf);
				          DP_xmin=NV_MAG(A)*(F_P(f,tf)+0.5*C_R(c,t)*SQR(C_U(c,t)));/*pressure of a small element face*/		
					    }
					   else
					   {
						  if  ((fabs(xf[2]-(zmax))<1e-4))/*indicates it is  boundary*/
						  {
							  cell_num_zmax++;
							  F_AREA(A,f,tf);
				             DP_zmax=NV_MAG(A)*(F_P(f,tf)+0.5*C_R(c,t)*SQR(C_W(c,t)));/*pressure of a small element face*/		
						  }
						  else
						  {
							  if ((fabs(xf[2]-(zmin))<1e-4))/*indicates it is  boundary*/
							  {
								  cell_num_zmin++;
								  F_AREA(A,f,tf);
				                  DP_zmin=NV_MAG(A)*(F_P(f,tf)+0.5*C_R(c,t)*SQR(C_W(c,t)));/*pressure of a small element face*/		
							  }
						  }
					  }
				   }
			   }
		 }   
		  P_xmax=P_xmax+DP_xmax;
		  P_xmin=P_xmin+DP_xmin;
	      F_Y=F_Y+f_buoyancy;
		  P_zmax=P_zmax+DP_zmax;
		  P_zmin=P_zmin+DP_zmin;
        }end_c_loop(c,t)
    fprintf(fp,"%-5g %-5g %-5g %-5g %-5g %-5g %-5g %-5g %-5g\n",P_xmax,P_xmin,F_Y,P_zmax,P_zmin,cell_num_xmax,cell_num_xmin, cell_num_zmax, cell_num_zmin);  /*write the coordinate*/
	fclose(fp);
	}
}


DEFINE_ON_DEMAND(report_inertial_force)
{
	/*this part may be not right*/
	Domain *d;
   	Thread *t;
    cell_t c;
	real xc[ND_ND],cell_num=0;

	real f_x=0,f_y=0,f_z=0;
	real f_x_sum=0,f_y_sum=0,f_z_sum=0,f_sum=0;
	real D,lf,xmax,xmin,zmin,zmax,source,volume,Q_xing;
	real DrhoDX=0,DrhoDY=0,DrhoDZ=0;
	real transient_term_x=0,transient_term_y=0,transient_term_z=0;
	
	FILE *fp; /*pointer to a file */
	fp = fopen("inertial_force.txt","a+");
	d = Get_Domain(1);
	
    D=2*(a+b)/M_PI;   /*D is perimeter diamter*/
	Q_xing=Q/(1.2*1.0*300*sqrt(9.81)*pow(D,2.5));
	lf=(3.7*pow(Q_xing,0.4)-1.02)*D;  /*calculate the height of fire*/
	if(lf>0.45)
	{	lf=0.45;}

	volume=a*b*lf;/*calculate the volume of fire source*/
	
    xmax=0.3+a/2;
    xmin=0.3-a/2;
    zmax=4.5+b/2;
    zmin=4.5-b/2;
    
	thread_loop_c(t,d)
	{
		begin_c_loop(c,t)
		{
		  C_CENTROID(xc,c,t);  /*get the center coordinates of one cell*/
		 if (xc[0]<=xmax && xc[0]>=xmin && xc[2]<=zmax && xc[2]>=zmin && xc[1]<=lf)  /*whether flame region*/
		  {
			   DrhoDX=(C_P_G(c,t)[0]-C_P(c,t)/C_T(c,t)*C_T_G(c,t)[0])/Rg/C_T(c,t);
			   DrhoDY=(C_P_G(c,t)[1]-C_P(c,t)/C_T(c,t)*C_T_G(c,t)[1])/Rg/C_T(c,t);
			   DrhoDZ=(C_P_G(c,t)[2]-C_P(c,t)/C_T(c,t)*C_T_G(c,t)[2])/Rg/C_T(c,t);
			   cell_num++;
			   transient_term_x=(C_R(c,t)*C_U(c,t)-C_U_M1(c,t)*C_R_M1(c,t))/CURRENT_TIMESTEP;
			   transient_term_y=(C_R(c,t)*C_V(c,t)-C_V_M1(c,t)*C_R_M1(c,t))/CURRENT_TIMESTEP;
			   transient_term_z=(C_R(c,t)*C_W(c,t)-C_W_M1(c,t)-C_R_M1(c,t))/CURRENT_TIMESTEP;
			   f_x=C_VOLUME(c,t)*(transient_term_x+C_U(c,t)*C_U(c,t)*DrhoDX+C_U(c,t)*C_V(c,t)*DrhoDY+C_U(c,t)*C_W(c,t)*DrhoDZ+2*C_R(c,t)*C_U(c,t)*C_DUDX(c,t)+C_R(c,t)*C_U(c,t)*C_DVDY(c,t)+C_R(c,t)*C_U(c,t)*C_DWDZ(c,t)+C_R(c,t)*C_V(c,t)*C_DUDY(c,t)+C_R(c,t)*C_W(c,t)*C_DUDZ(c,t));
			   f_y=C_VOLUME(c,t)*(transient_term_y+C_V(c,t)*C_U(c,t)*DrhoDX+C_V(c,t)*C_V(c,t)*DrhoDY+C_V(c,t)*C_W(c,t)*DrhoDZ+2*C_R(c,t)*C_V(c,t)*C_DVDY(c,t)+C_R(c,t)*C_U(c,t)*C_DVDX(c,t)+C_R(c,t)*C_V(c,t)*C_DUDX(c,t)+C_R(c,t)*C_W(c,t)*C_DVDZ(c,t)+C_R(c,t)*C_V(c,t)*C_DWDZ(c,t));
			   f_z=C_VOLUME(c,t)*(transient_term_z+C_W(c,t)*C_U(c,t)*DrhoDX+C_W(c,t)*C_V(c,t)*DrhoDY+C_W(c,t)*C_W(c,t)*DrhoDZ+2*C_R(c,t)*C_W(c,t)*C_DWDZ(c,t)+C_R(c,t)*C_W(c,t)*C_DUDX(c,t)+C_R(c,t)*C_U(c,t)*C_DWDX(c,t)+C_R(c,t)*C_W(c,t)*C_DVDY(c,t)+C_R(c,t)*C_V(c,t)*C_DWDY(c,t));
	      }
		  f_x_sum=f_x_sum+f_x;
		  f_y_sum=f_y_sum+f_y;
		  f_z_sum=f_z_sum+f_z;
		  f_sum=sqrt(SQR(f_x_sum)+SQR(f_y_sum)+SQR(f_z_sum));
		}end_c_loop(c,t)
	}
	fprintf(fp,"%-5g %-5g %-5g %-5g %-5g %-5g\n",f_x_sum,f_y_sum,f_z_sum,f_sum,volume,lf);  /*write the coordinate*/
	fclose(fp);
}
